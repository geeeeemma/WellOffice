//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class WellOfficeApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    environments(): Promise<EnvironmentDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/environments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironments(_response);
        });
    }

    protected processEnvironments(response: Response): Promise<EnvironmentDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnvironmentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnvironmentDto[]>(null as any);
    }

    /**
     * @return Success
     */
    parameterAll(): Promise<Parameter[]> {
        let url_ = this.baseUrl + "/api/Parameter";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParameterAll(_response);
        });
    }

    protected processParameterAll(response: Response): Promise<Parameter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Parameter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Parameter[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    parameterPOST(body: Parameter | undefined): Promise<Parameter> {
        let url_ = this.baseUrl + "/api/Parameter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParameterPOST(_response);
        });
    }

    protected processParameterPOST(response: Response): Promise<Parameter> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Parameter>(null as any);
    }

    /**
     * @return Success
     */
    parameterGET(id: string): Promise<Parameter> {
        let url_ = this.baseUrl + "/api/Parameter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParameterGET(_response);
        });
    }

    protected processParameterGET(response: Response): Promise<Parameter> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Parameter>(null as any);
    }

    /**
     * @return Success
     */
    withSensors(): Promise<Parameter[]> {
        let url_ = this.baseUrl + "/api/Parameter/with-sensors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithSensors(_response);
        });
    }

    protected processWithSensors(response: Response): Promise<Parameter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Parameter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Parameter[]>(null as any);
    }

    /**
     * @return Success
     */
    withThresholds(): Promise<Parameter[]> {
        let url_ = this.baseUrl + "/api/Parameter/with-thresholds";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithThresholds(_response);
        });
    }

    protected processWithThresholds(response: Response): Promise<Parameter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Parameter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Parameter[]>(null as any);
    }

    /**
     * @return Success
     */
    remediationActionAll(): Promise<RemediationAction[]> {
        let url_ = this.baseUrl + "/api/RemediationAction";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemediationActionAll(_response);
        });
    }

    protected processRemediationActionAll(response: Response): Promise<RemediationAction[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RemediationAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemediationAction[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    remediationActionPOST(body: RemediationAction | undefined): Promise<RemediationAction> {
        let url_ = this.baseUrl + "/api/RemediationAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemediationActionPOST(_response);
        });
    }

    protected processRemediationActionPOST(response: Response): Promise<RemediationAction> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemediationAction.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemediationAction>(null as any);
    }

    /**
     * @return Success
     */
    remediationActionGET(id: string): Promise<RemediationAction> {
        let url_ = this.baseUrl + "/api/RemediationAction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemediationActionGET(_response);
        });
    }

    protected processRemediationActionGET(response: Response): Promise<RemediationAction> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemediationAction.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemediationAction>(null as any);
    }

    /**
     * @return Success
     */
    sensor(sensorId: string): Promise<RemediationAction[]> {
        let url_ = this.baseUrl + "/api/RemediationAction/sensor/{sensorId}";
        if (sensorId === undefined || sensorId === null)
            throw new Error("The parameter 'sensorId' must be defined.");
        url_ = url_.replace("{sensorId}", encodeURIComponent("" + sensorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensor(_response);
        });
    }

    protected processSensor(response: Response): Promise<RemediationAction[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RemediationAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemediationAction[]>(null as any);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    latest(sensorId: string, count: number | undefined): Promise<RemediationAction[]> {
        let url_ = this.baseUrl + "/api/RemediationAction/sensor/{sensorId}/latest?";
        if (sensorId === undefined || sensorId === null)
            throw new Error("The parameter 'sensorId' must be defined.");
        url_ = url_.replace("{sensorId}", encodeURIComponent("" + sensorId));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLatest(_response);
        });
    }

    protected processLatest(response: Response): Promise<RemediationAction[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RemediationAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemediationAction[]>(null as any);
    }

    /**
     * @return Success
     */
    roomAll(): Promise<Room[]> {
        let url_ = this.baseUrl + "/api/Room";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoomAll(_response);
        });
    }

    protected processRoomAll(response: Response): Promise<Room[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Room.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Room[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    roomPOST(body: Room | undefined): Promise<Room> {
        let url_ = this.baseUrl + "/api/Room";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoomPOST(_response);
        });
    }

    protected processRoomPOST(response: Response): Promise<Room> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Room.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Room>(null as any);
    }

    /**
     * @return Success
     */
    roomGET(id: string): Promise<Room> {
        let url_ = this.baseUrl + "/api/Room/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoomGET(_response);
        });
    }

    protected processRoomGET(response: Response): Promise<Room> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Room.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Room>(null as any);
    }

    /**
     * @return Success
     */
    withSensors2(): Promise<Room[]> {
        let url_ = this.baseUrl + "/api/Room/with-sensors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithSensors2(_response);
        });
    }

    protected processWithSensors2(response: Response): Promise<Room[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Room.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Room[]>(null as any);
    }

    /**
     * @return Success
     */
    withThresholds2(): Promise<Room[]> {
        let url_ = this.baseUrl + "/api/Room/with-thresholds";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWithThresholds2(_response);
        });
    }

    protected processWithThresholds2(response: Response): Promise<Room[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Room.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Room[]>(null as any);
    }

    /**
     * @return Success
     */
    sensorAll(): Promise<Sensor[]> {
        let url_ = this.baseUrl + "/api/Sensor";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensorAll(_response);
        });
    }

    protected processSensorAll(response: Response): Promise<Sensor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sensor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Sensor[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sensorPOST(body: Sensor | undefined): Promise<Sensor> {
        let url_ = this.baseUrl + "/api/Sensor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensorPOST(_response);
        });
    }

    protected processSensorPOST(response: Response): Promise<Sensor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sensor.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Sensor>(null as any);
    }

    /**
     * @return Success
     */
    sensorGET(id: string): Promise<Sensor> {
        let url_ = this.baseUrl + "/api/Sensor/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensorGET(_response);
        });
    }

    protected processSensorGET(response: Response): Promise<Sensor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sensor.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Sensor>(null as any);
    }

    /**
     * @return Success
     */
    room(roomId: string): Promise<Sensor[]> {
        let url_ = this.baseUrl + "/api/Sensor/room/{roomId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoom(_response);
        });
    }

    protected processRoom(response: Response): Promise<Sensor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sensor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Sensor[]>(null as any);
    }

    /**
     * @return Success
     */
    parameter(parameterId: string): Promise<Sensor[]> {
        let url_ = this.baseUrl + "/api/Sensor/parameter/{parameterId}";
        if (parameterId === undefined || parameterId === null)
            throw new Error("The parameter 'parameterId' must be defined.");
        url_ = url_.replace("{parameterId}", encodeURIComponent("" + parameterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParameter(_response);
        });
    }

    protected processParameter(response: Response): Promise<Sensor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Sensor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Sensor[]>(null as any);
    }

    /**
     * @return Success
     */
    sensorDataAll(): Promise<SensorData[]> {
        let url_ = this.baseUrl + "/api/SensorData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensorDataAll(_response);
        });
    }

    protected processSensorDataAll(response: Response): Promise<SensorData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SensorData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorData[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sensorDataPOST(body: SensorData | undefined): Promise<SensorData> {
        let url_ = this.baseUrl + "/api/SensorData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensorDataPOST(_response);
        });
    }

    protected processSensorDataPOST(response: Response): Promise<SensorData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorData>(null as any);
    }

    /**
     * @return Success
     */
    sensorDataGET(id: string): Promise<SensorData> {
        let url_ = this.baseUrl + "/api/SensorData/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensorDataGET(_response);
        });
    }

    protected processSensorDataGET(response: Response): Promise<SensorData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorData>(null as any);
    }

    /**
     * @return Success
     */
    sensor2(sensorId: string): Promise<SensorData[]> {
        let url_ = this.baseUrl + "/api/SensorData/sensor/{sensorId}";
        if (sensorId === undefined || sensorId === null)
            throw new Error("The parameter 'sensorId' must be defined.");
        url_ = url_.replace("{sensorId}", encodeURIComponent("" + sensorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSensor2(_response);
        });
    }

    protected processSensor2(response: Response): Promise<SensorData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SensorData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorData[]>(null as any);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    latest2(sensorId: string, count: number | undefined): Promise<SensorData[]> {
        let url_ = this.baseUrl + "/api/SensorData/sensor/{sensorId}/latest?";
        if (sensorId === undefined || sensorId === null)
            throw new Error("The parameter 'sensorId' must be defined.");
        url_ = url_.replace("{sensorId}", encodeURIComponent("" + sensorId));
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLatest2(_response);
        });
    }

    protected processLatest2(response: Response): Promise<SensorData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SensorData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorData[]>(null as any);
    }

    /**
     * @return Success
     */
    thresholdAll(): Promise<Threshold[]> {
        let url_ = this.baseUrl + "/api/Threshold";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThresholdAll(_response);
        });
    }

    protected processThresholdAll(response: Response): Promise<Threshold[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Threshold.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Threshold[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    thresholdPOST(body: Threshold | undefined): Promise<Threshold> {
        let url_ = this.baseUrl + "/api/Threshold";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThresholdPOST(_response);
        });
    }

    protected processThresholdPOST(response: Response): Promise<Threshold> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Threshold.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Threshold>(null as any);
    }

    /**
     * @return Success
     */
    thresholdGET(id: string): Promise<Threshold> {
        let url_ = this.baseUrl + "/api/Threshold/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThresholdGET(_response);
        });
    }

    protected processThresholdGET(response: Response): Promise<Threshold> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Threshold.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Threshold>(null as any);
    }

    /**
     * @return Success
     */
    room2(roomId: string): Promise<Threshold[]> {
        let url_ = this.baseUrl + "/api/Threshold/room/{roomId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoom2(_response);
        });
    }

    protected processRoom2(response: Response): Promise<Threshold[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Threshold.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Threshold[]>(null as any);
    }

    /**
     * @return Success
     */
    parameter2(parameterId: string): Promise<Threshold[]> {
        let url_ = this.baseUrl + "/api/Threshold/parameter/{parameterId}";
        if (parameterId === undefined || parameterId === null)
            throw new Error("The parameter 'parameterId' must be defined.");
        url_ = url_.replace("{parameterId}", encodeURIComponent("" + parameterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParameter2(_response);
        });
    }

    protected processParameter2(response: Response): Promise<Threshold[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Threshold.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Threshold[]>(null as any);
    }

    /**
     * @return Success
     */
    getWeatherForecast(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWeatherForecast(_response);
        });
    }

    protected processGetWeatherForecast(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class BorderlineRangeDto implements IBorderlineRangeDto {
    min?: number;
    max?: number;

    constructor(data?: IBorderlineRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): BorderlineRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorderlineRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        return data;
    }
}

export interface IBorderlineRangeDto {
    min?: number;
    max?: number;
}

export class DateOnly implements IDateOnly {
    year?: number;
    month?: number;
    day?: number;
    dayOfWeek?: DayOfWeek;
    readonly dayOfYear?: number;
    readonly dayNumber?: number;

    constructor(data?: IDateOnly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.day = _data["day"];
            this.dayOfWeek = _data["dayOfWeek"];
            (<any>this).dayOfYear = _data["dayOfYear"];
            (<any>this).dayNumber = _data["dayNumber"];
        }
    }

    static fromJS(data: any): DateOnly {
        data = typeof data === 'object' ? data : {};
        let result = new DateOnly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["dayOfWeek"] = this.dayOfWeek;
        data["dayOfYear"] = this.dayOfYear;
        data["dayNumber"] = this.dayNumber;
        return data;
    }
}

export interface IDateOnly {
    year?: number;
    month?: number;
    day?: number;
    dayOfWeek?: DayOfWeek;
    dayOfYear?: number;
    dayNumber?: number;
}

export enum DayOfWeek {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class EnvironmentDto implements IEnvironmentDto {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    area?: number;
    parameters?: EnvironmentParameterDto[] | undefined;
    lastUpdated?: string | undefined;

    constructor(data?: IEnvironmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.area = _data["area"];
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(EnvironmentParameterDto.fromJS(item));
            }
            this.lastUpdated = _data["lastUpdated"];
        }
    }

    static fromJS(data: any): EnvironmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["area"] = this.area;
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item ? item.toJSON() : <any>undefined);
        }
        data["lastUpdated"] = this.lastUpdated;
        return data;
    }
}

export interface IEnvironmentDto {
    id?: string | undefined;
    name?: string | undefined;
    type?: string | undefined;
    area?: number;
    parameters?: EnvironmentParameterDto[] | undefined;
    lastUpdated?: string | undefined;
}

export class EnvironmentParameterDto implements IEnvironmentParameterDto {
    id?: string | undefined;
    name?: string | undefined;
    value?: number;
    unit?: string | undefined;
    status?: string | undefined;
    thresholds?: ThresholdsDto;
    isActive?: boolean;
    sensors?: EnvironmentSensorDto[] | undefined;

    constructor(data?: IEnvironmentParameterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.unit = _data["unit"];
            this.status = _data["status"];
            this.thresholds = _data["thresholds"] ? ThresholdsDto.fromJS(_data["thresholds"]) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["sensors"])) {
                this.sensors = [] as any;
                for (let item of _data["sensors"])
                    this.sensors!.push(EnvironmentSensorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnvironmentParameterDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentParameterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["unit"] = this.unit;
        data["status"] = this.status;
        data["thresholds"] = this.thresholds ? this.thresholds.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.sensors)) {
            data["sensors"] = [];
            for (let item of this.sensors)
                data["sensors"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IEnvironmentParameterDto {
    id?: string | undefined;
    name?: string | undefined;
    value?: number;
    unit?: string | undefined;
    status?: string | undefined;
    thresholds?: ThresholdsDto;
    isActive?: boolean;
    sensors?: EnvironmentSensorDto[] | undefined;
}

export class EnvironmentSensorDto implements IEnvironmentSensorDto {
    id?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;

    constructor(data?: IEnvironmentSensorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): EnvironmentSensorDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentSensorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IEnvironmentSensorDto {
    id?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
}

export class OptimalRangeDto implements IOptimalRangeDto {
    min?: number;
    max?: number;

    constructor(data?: IOptimalRangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.min = _data["min"];
            this.max = _data["max"];
        }
    }

    static fromJS(data: any): OptimalRangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptimalRangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        return data;
    }
}

export interface IOptimalRangeDto {
    min?: number;
    max?: number;
}

export class Parameter implements IParameter {
    id?: string;
    name?: string | undefined;
    unitMeasure?: UnitMeasure;
    sensors?: Sensor[] | undefined;
    thresholds?: Threshold[] | undefined;

    constructor(data?: IParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.unitMeasure = _data["unitMeasure"];
            if (Array.isArray(_data["sensors"])) {
                this.sensors = [] as any;
                for (let item of _data["sensors"])
                    this.sensors!.push(Sensor.fromJS(item));
            }
            if (Array.isArray(_data["thresholds"])) {
                this.thresholds = [] as any;
                for (let item of _data["thresholds"])
                    this.thresholds!.push(Threshold.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Parameter {
        data = typeof data === 'object' ? data : {};
        let result = new Parameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unitMeasure"] = this.unitMeasure;
        if (Array.isArray(this.sensors)) {
            data["sensors"] = [];
            for (let item of this.sensors)
                data["sensors"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.thresholds)) {
            data["thresholds"] = [];
            for (let item of this.thresholds)
                data["thresholds"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IParameter {
    id?: string;
    name?: string | undefined;
    unitMeasure?: UnitMeasure;
    sensors?: Sensor[] | undefined;
    thresholds?: Threshold[] | undefined;
}

export class RemediationAction implements IRemediationAction {
    id?: string;
    sensorId?: string;
    action?: string | undefined;
    actionDate?: Date;
    sensor?: Sensor;

    constructor(data?: IRemediationAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sensorId = _data["sensorId"];
            this.action = _data["action"];
            this.actionDate = _data["actionDate"] ? new Date(_data["actionDate"].toString()) : <any>undefined;
            this.sensor = _data["sensor"] ? Sensor.fromJS(_data["sensor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RemediationAction {
        data = typeof data === 'object' ? data : {};
        let result = new RemediationAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sensorId"] = this.sensorId;
        data["action"] = this.action;
        data["actionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["sensor"] = this.sensor ? this.sensor.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRemediationAction {
    id?: string;
    sensorId?: string;
    action?: string | undefined;
    actionDate?: Date;
    sensor?: Sensor;
}

export class Room implements IRoom {
    id?: string;
    name?: string | undefined;
    footage?: number;
    ceilingHeight?: number;
    sensors?: Sensor[] | undefined;
    thresholds?: Threshold[] | undefined;

    constructor(data?: IRoom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.footage = _data["footage"];
            this.ceilingHeight = _data["ceilingHeight"];
            if (Array.isArray(_data["sensors"])) {
                this.sensors = [] as any;
                for (let item of _data["sensors"])
                    this.sensors!.push(Sensor.fromJS(item));
            }
            if (Array.isArray(_data["thresholds"])) {
                this.thresholds = [] as any;
                for (let item of _data["thresholds"])
                    this.thresholds!.push(Threshold.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Room {
        data = typeof data === 'object' ? data : {};
        let result = new Room();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["footage"] = this.footage;
        data["ceilingHeight"] = this.ceilingHeight;
        if (Array.isArray(this.sensors)) {
            data["sensors"] = [];
            for (let item of this.sensors)
                data["sensors"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.thresholds)) {
            data["thresholds"] = [];
            for (let item of this.thresholds)
                data["thresholds"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface IRoom {
    id?: string;
    name?: string | undefined;
    footage?: number;
    ceilingHeight?: number;
    sensors?: Sensor[] | undefined;
    thresholds?: Threshold[] | undefined;
}

export class Sensor implements ISensor {
    id?: string;
    name?: string | undefined;
    parameterId?: string;
    roomId?: string;
    isActive?: boolean;
    parameter?: Parameter;
    room?: Room;
    sensorData?: SensorData[] | undefined;
    remediationActions?: RemediationAction[] | undefined;

    constructor(data?: ISensor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parameterId = _data["parameterId"];
            this.roomId = _data["roomId"];
            this.isActive = _data["isActive"];
            this.parameter = _data["parameter"] ? Parameter.fromJS(_data["parameter"]) : <any>undefined;
            this.room = _data["room"] ? Room.fromJS(_data["room"]) : <any>undefined;
            if (Array.isArray(_data["sensorData"])) {
                this.sensorData = [] as any;
                for (let item of _data["sensorData"])
                    this.sensorData!.push(SensorData.fromJS(item));
            }
            if (Array.isArray(_data["remediationActions"])) {
                this.remediationActions = [] as any;
                for (let item of _data["remediationActions"])
                    this.remediationActions!.push(RemediationAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Sensor {
        data = typeof data === 'object' ? data : {};
        let result = new Sensor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parameterId"] = this.parameterId;
        data["roomId"] = this.roomId;
        data["isActive"] = this.isActive;
        data["parameter"] = this.parameter ? this.parameter.toJSON() : <any>undefined;
        data["room"] = this.room ? this.room.toJSON() : <any>undefined;
        if (Array.isArray(this.sensorData)) {
            data["sensorData"] = [];
            for (let item of this.sensorData)
                data["sensorData"].push(item ? item.toJSON() : <any>undefined);
        }
        if (Array.isArray(this.remediationActions)) {
            data["remediationActions"] = [];
            for (let item of this.remediationActions)
                data["remediationActions"].push(item ? item.toJSON() : <any>undefined);
        }
        return data;
    }
}

export interface ISensor {
    id?: string;
    name?: string | undefined;
    parameterId?: string;
    roomId?: string;
    isActive?: boolean;
    parameter?: Parameter;
    room?: Room;
    sensorData?: SensorData[] | undefined;
    remediationActions?: RemediationAction[] | undefined;
}

export class SensorData implements ISensorData {
    id?: string;
    sensorId?: string;
    value?: number;
    detectionDate?: Date;
    sensor?: Sensor;

    constructor(data?: ISensorData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sensorId = _data["sensorId"];
            this.value = _data["value"];
            this.detectionDate = _data["detectionDate"] ? new Date(_data["detectionDate"].toString()) : <any>undefined;
            this.sensor = _data["sensor"] ? Sensor.fromJS(_data["sensor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SensorData {
        data = typeof data === 'object' ? data : {};
        let result = new SensorData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sensorId"] = this.sensorId;
        data["value"] = this.value;
        data["detectionDate"] = this.detectionDate ? this.detectionDate.toISOString() : <any>undefined;
        data["sensor"] = this.sensor ? this.sensor.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISensorData {
    id?: string;
    sensorId?: string;
    value?: number;
    detectionDate?: Date;
    sensor?: Sensor;
}

export class Threshold implements IThreshold {
    id?: string;
    parameterId?: string;
    roomId?: string;
    optimalMinValue?: number;
    optimalMaxValue?: number;
    acceptableMinValue?: number;
    acceptableMaxValue?: number;
    parameter?: Parameter;
    room?: Room;

    constructor(data?: IThreshold) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parameterId = _data["parameterId"];
            this.roomId = _data["roomId"];
            this.optimalMinValue = _data["optimalMinValue"];
            this.optimalMaxValue = _data["optimalMaxValue"];
            this.acceptableMinValue = _data["acceptableMinValue"];
            this.acceptableMaxValue = _data["acceptableMaxValue"];
            this.parameter = _data["parameter"] ? Parameter.fromJS(_data["parameter"]) : <any>undefined;
            this.room = _data["room"] ? Room.fromJS(_data["room"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Threshold {
        data = typeof data === 'object' ? data : {};
        let result = new Threshold();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parameterId"] = this.parameterId;
        data["roomId"] = this.roomId;
        data["optimalMinValue"] = this.optimalMinValue;
        data["optimalMaxValue"] = this.optimalMaxValue;
        data["acceptableMinValue"] = this.acceptableMinValue;
        data["acceptableMaxValue"] = this.acceptableMaxValue;
        data["parameter"] = this.parameter ? this.parameter.toJSON() : <any>undefined;
        data["room"] = this.room ? this.room.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThreshold {
    id?: string;
    parameterId?: string;
    roomId?: string;
    optimalMinValue?: number;
    optimalMaxValue?: number;
    acceptableMinValue?: number;
    acceptableMaxValue?: number;
    parameter?: Parameter;
    room?: Room;
}

export class ThresholdsDto implements IThresholdsDto {
    optimal?: OptimalRangeDto;
    borderline?: BorderlineRangeDto;

    constructor(data?: IThresholdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optimal = _data["optimal"] ? OptimalRangeDto.fromJS(_data["optimal"]) : <any>undefined;
            this.borderline = _data["borderline"] ? BorderlineRangeDto.fromJS(_data["borderline"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThresholdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThresholdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optimal"] = this.optimal ? this.optimal.toJSON() : <any>undefined;
        data["borderline"] = this.borderline ? this.borderline.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThresholdsDto {
    optimal?: OptimalRangeDto;
    borderline?: BorderlineRangeDto;
}

export enum UnitMeasure {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class WeatherForecast implements IWeatherForecast {
    date?: DateOnly;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateOnly.fromJS(_data["date"]) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: DateOnly;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}